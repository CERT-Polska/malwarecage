import React, {useState, useEffect} from 'react';
import {Link} from 'react-router-dom';

import queryString from "query-string";

import api from "@malwarefront/api";
import { encodeSearchQuery, decodeSearchQuery, escapeSearchValue } from "@malwarefront/helpers";
import { View } from "@malwarefront/ui";

import RecentViewList from "./RecentViewList";
import QuickQuery from "./QuickQuery";

function transformHash(query, dhashOnly) {
    // SHA256
    if((/^[0-9a-fA-F]{64}$/g).test(query))
        if(dhashOnly)
            return `dhash:${query.toLowerCase()}`
        else
            return `sha256:${query.toLowerCase()}`
    // No SHA256 and dhashOnly? Time to stop
    if(dhashOnly)
        return query
    // SHA1
    if((/^[0-9a-fA-F]{40}$/g).test(query))
        return `sha1:${query.toLowerCase()}`
    // MD5
    if((/^[0-9a-fA-F]{32}$/g).test(query))
        return `md5:${query.toLowerCase()}`
    // SHA512
    if((/^[0-9a-fA-F]{128}$/g).test(query))
        return `sha512:${query.toLowerCase()}`
    return query
}

export default function RecentView(props) {
    const currentQuery = decodeSearchQuery(
        (queryString.parse(props.location.search)["q"] || "").trim()
    );
    const setCurrentQuery = (query) => {
        props.history.push(`${props.location.pathname}?q=${encodeSearchQuery(query)}`);
    }

    // Query input state
    let [queryInput, setQueryInput] = useState(currentQuery);
    // Submitted input state
    // If submittedQuery !== currentQuery: query is uncommitted and needs to be loaded
    let [submittedQuery, setSubmittedQuery] = useState(currentQuery);
    // General error shown in Alert
    let [error, setError] = useState(null);
    // Query error shown under the query bar
    let [queryError, setQueryError] = useState(null);

    const isLocked = (
        !queryError && submittedQuery !== currentQuery
    )

    const resetErrors = () => {
        setError(null);
        setQueryError(null);
    }

    const submitQuery = (query) => {
        // If query is already submitted: do nothing
        if(query === submittedQuery)
            return;
        query = transformHash(query, props.dhashOnly);
        // Synchronize input
        setQueryInput(query);
        resetErrors();
        // Submit query
        setSubmittedQuery(query);
    };

    const addToQuery = (field, value) => {
        const OP_NOT = "NOT "
        const OP_AND = " AND "
        const OP_PRE_AND = "AND "

        let negateQueryComponent = (component) => 
            component.startsWith(OP_NOT) ? component.substring(OP_NOT.length) : OP_NOT + component;

        let queryComponent = `${field}:${escapeSearchValue(value)}`
        let queryValue = queryInput;
        if(!queryValue) {
            queryValue = queryComponent;
        }
        else {
            if(field.startsWith(OP_NOT)){
                // Let ~negated query pass condition
                if (queryValue.includes(queryComponent)){}
                // Remove AND ~query
                else if(queryValue.includes(OP_AND + negateQueryComponent(queryComponent)))
                    queryValue = queryValue.replace(OP_AND + negateQueryComponent(queryComponent), "")
                // Remove ~query
                else if(queryValue.includes(negateQueryComponent(queryComponent)))
                    queryValue = queryValue.replace(negateQueryComponent(queryComponent), "")
                // Add ~query
                else
                    queryValue = queryValue + OP_AND + queryComponent
            }
            // Remove AND ~negated query
            else if(queryValue.includes(OP_AND + negateQueryComponent(queryComponent)))
                queryValue = queryValue.replace(OP_AND + negateQueryComponent(queryComponent), "")
            // Remove ~negated query
            else if(queryValue.includes(negateQueryComponent(queryComponent)))
                queryValue = queryValue.replace(negateQueryComponent(queryComponent), "")
            // Remove duplicated query
            else if(!queryValue.includes(queryComponent))
                queryValue = queryValue + OP_AND + queryComponent 
        }
        queryValue = queryValue.trim()
        if(queryValue.startsWith(OP_PRE_AND))
            queryValue = queryValue.substring(OP_PRE_AND.length)
        submitQuery(queryValue)
    }

    // Commit submitted query
    useEffect(() => {
        let cancelled = false;
        // If query is already committed: do nothing
        if(submittedQuery === currentQuery)
            return;
        // Make preflight query to check if query is correct
        api.getObjectList(
            props.type, 
            null, // no pivot, load first page
            submittedQuery
        ).then(() => {
            if(cancelled)
                return;
            // If ok: commit query
            setCurrentQuery(submittedQuery);
        }).catch((error) => {
            if(cancelled)
                return;
            setQueryError(error);
        })
        return () => { cancelled = true; }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [submittedQuery])

    // Synchronize changed current (committed) query (history back/forward)
    useEffect(() => {
        setQueryInput(currentQuery);
        resetErrors();
        setSubmittedQuery(currentQuery);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [currentQuery]);

    const canAddQuickQuery = (
        queryInput && !isLocked && queryInput === currentQuery
    )

    const queryErrorMessage = (
        queryError ? (
            <div className="form-hint">
                {
                    queryError.response 
                    ? queryError.response.data["message"] 
                    : queryError.toString()
                }
            </div>
        ) : []
    )

    return (
        <View fluid ident="RecentObjects" error={error}>
            <div className="table-responsive">
                <form className="searchForm" onSubmit={(ev) => {ev.preventDefault(); submitQuery(queryInput);}}>
                    <div className="input-group">
                        <div className="input-group-prepend">
                            <input className="btn btn-outline-danger" type="button" value="X" 
                                   onClick={(ev) => {ev.preventDefault(); submitQuery("")}}/>
                        </div>
                        <input className="form-control small" 
                               type="text" 
                               placeholder="Search (Lucene query or hash)..." 
                               value={queryInput}
                               disabled={isLocked}
                               onChange={(evt) => setQueryInput(evt.target.value)}/>
                        <div className="input-group-append">
                            <input className="btn btn-outline-success" type="submit" value="Search"/>
                            <Link to="/search_help" className="btn btn-outline-primary">?</Link>
                        </div>
                    </div>
                        <div className="input-group">
                            {queryErrorMessage}
                            <QuickQuery type={props.type} query={currentQuery}
                                        canAddQuickQuery={canAddQuickQuery}
                                        submitQuery={q => submitQuery(q)}
                                        addToQuery={addToQuery}
                                        setQueryError={setQueryError}/>
                        </div>
                    </form>
                <RecentViewList query={currentQuery}
                                type={props.type}
                                objectRow={props.objectRow}
                                setError={setError}
                                locked={isLocked}
                                addToQuery={addToQuery} />
            </div>
        </View>
    );
}
