import React, { useEffect, useRef, useState, useLayoutEffect } from 'react';
import ReactDOM from 'react-dom';

import * as dagreD3 from "dagre-d3";
import * as d3 from "d3";
import api from "@malwarefront/api";
import { capitalize } from "@malwarefront/helpers";

import {Tag} from "./Tag";

function RelationsPlotRenderer(props) {
    const graph = new dagreD3.graphlib.Graph().setGraph({compound: true});
    const renderer = new dagreD3.render();
    
    const masterContainer = useRef(null);
    const slaveContainer = useRef(null);
    const nodeTree = useRef(null);
    const nodeTreeGroup = useRef(null);
    
    graph.graph().transition = (selection) => selection.transition().duration(500);

    const zoomIdentity = () => (
        d3.zoomIdentity.translate(nodeTree.current.parentNode.clientWidth / 2 - 200, props.height / 3 - 100)
    );

    const renderSingleNode = async (node) => {
        const typeMapping = {
            file: "sample",
            config: "config",
            static_config: "config",
            text_blob: "blob"
        }

        const styleMapping = {
            sample: "bg-danger",
            config: "bg-success",
            blob: "bg-info"
        }

        const nodeType = typeMapping[node.object.type];
        const nodeStyle = styleMapping[nodeType];
        const nodeHeaderStyle = node.expanded ? "node-header-expanded": "node-header-active"

        const parentNode = document.createElement("div");
        const nodeComponent = (
            <div className='mainNode'> 
                <div className="card" style={{width: "13rem", cursor: "pointer"}}>
                    <div className={`card-header ${nodeHeaderStyle} ${nodeStyle}`} 
                         style={{ paddingTop: "11px", paddingBottom: "11px" }}>
                        {capitalize(nodeType)}{" "}
                        <span className="date">
                            {new Date(node.object.upload_time).toLocaleDateString()}
                        </span>
                    </div>
                    <div className="card-body">
                        <p className="card-text">
                            <small className="text-muted">
                                <a href={`/${nodeType}/${node.id}`}>
                                    {node.id.substr(0,16)}
                                </a>
                            </small>
                        </p>
                    </div>
                    <div className="card-footer bg-transparent tags" 
                         style={{ maxWidth: "13rem", whiteSpace: "pre-wrap" }}>
                    {
                        node.object.tags.map(tag => <Tag tag={tag.tag} searchable={false}/>)
                    }
                    </div>
                </div>
            </div>
        );
        // ReactDOM.render is asynchronic - node render is deferred
        return new Promise(resolve => {
            ReactDOM.render(nodeComponent, parentNode, () => resolve(parentNode));
        })
    }

    const updateGraph = async () => {
        // Clone current tree view to hide flickering
        const nodeTreeClone = nodeTree.current.cloneNode(true);
        masterContainer.current.replaceChild(nodeTreeClone, nodeTree.current);
        slaveContainer.current.appendChild(nodeTree.current);

        // Acquire d3 nodes
        const svg = d3.select(nodeTree.current);
        const inner = d3.select(nodeTreeGroup.current);
        
        // Store and reset transform for time of rendering
        let transform = inner.attr("transform");
        if(!transform)
        {
            transform = zoomIdentity()
        }
        inner.attr("transform", "")

        // Render all node components
        let renderedNodes = await Promise.all(
            props.nodes.map(
                async (node) => [node, await renderSingleNode(node)]
            )
        )

        for(let [node, element] of renderedNodes) {
            graph.setNode(node.id, {
                labelType: "html",
                label: element.outerHTML,
                class: (node.expanded ? "expanded-node" : "not-expanded-node")
            })
        }

        for(let edge of props.edges)
        {
            graph.setEdge(edge.parent, edge.child, {label: "", lineInterpolate: "basis"})
        }

        graph.nodes().forEach((v) => {
            let node = graph.node(v);

            node.rx = node.ry = 5;
            node.padding = 0;
        });

        graph.graph().rankDir = 'LR';

        graph.edges().forEach(e => graph.edge(e));

        const zoom = d3.zoom().on("zoom", () => inner.attr("transform", d3.event.transform + zoomIdentity()));
        svg.call(zoom);

        renderer(inner, graph);
        
        inner.attr("transform", transform)

        svg.selectAll('.dagre-d3 .node').on('click', id => props.onNodeClick(id));

        svg.attr("height", props.height);
        svg.attr("width", props.width);

        masterContainer.current.replaceChild(nodeTree.current, nodeTreeClone);
    }

    useEffect(() => {
        updateGraph()
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [props.nodes, props.edges])

    return (
        <div ref={masterContainer}>
            <svg className='dagre-d3' ref={nodeTree}
                width={props.width}
                height={props.height}>
                <g ref={nodeTreeGroup}/>
            </svg>
            <div style={{visibility: "hidden"}} ref={slaveContainer}></div>
        </div>
    );
}


function RelationsPlot(props) {

    const { hash } = props

    const defaultProps = {
        height: "900",
        width: "100%",
    };

    const initialState = {
        nodes: [],
        edges: [],
    }

    const [nodes, setNodes] = useState(initialState)

    const convertObject = (obj) => {
        let node = {
            id: obj.id,
            object: {
                type: obj.type,
                upload_time: obj.upload_time,
                tags: obj.tags
            },
            expanded: false
        }
        return node
    }

    const updateNodes = async (hash) => {
        let objectInfo = await api.getObject("object", hash);
        let obj = objectInfo.data
        let node = convertObject(obj)
        let currentNodes = nodes.nodes.map((v) => v.id)
        if (currentNodes.indexOf(node.id) === -1) {
            setNodes(
           (prevNodes) => ({
                   nodes: [...prevNodes.nodes, node],
                   edges: [...prevNodes.edges],
                   }
               )
            )
        }
        if (obj.parents.length > 0) {
            obj.parents.forEach((o) => {
                let parent = convertObject(o)
                setNodes((prevNodes) => ({
                        nodes: [...prevNodes.nodes, parent],
                        edges: [...prevNodes.edges, { parent: parent.id, child: node.id}]
                       }
                   )
                )
            })
        }
        if (obj.children.length > 0) {
            obj.children.forEach((o) => {
                let children = convertObject(o)
                setNodes((prevNodes) => ({
                        nodes: [...prevNodes.nodes, children],
                        edges: [...prevNodes.edges, { parent: node.id, child: children.id}]
                       }
                   )
                )
            })
        }
    }

    const onNodeClick = (node) => {
        updateNodes(node)
    }

    useLayoutEffect(() => {
            updateNodes(hash)
        // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [])

    console.log(nodes)
    return (
            <RelationsPlotRenderer width={defaultProps.width}
                                   height={defaultProps.height}
                                   nodes={nodes.nodes}
                                   edges={nodes.edges}
                                   onNodeClick={onNodeClick}/>
                                   )
}

export default RelationsPlot;
